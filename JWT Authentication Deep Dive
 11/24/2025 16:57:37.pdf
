````md
<div align="center">

<h1>ğŸ”¥ Mengamankan Aplikasi Web dengan JWT (JSON Web Tokens) ğŸ”¥</h1>
<p><i>Panduan teknis yang sangat detail untuk mengimplementasikan autentikasi berbasis token yang aman.</i></p>
<img src="https://img.shields.io/badge/Type-IT Tutorial-blue?style=flat-square"/>
<img src="https://img.shields.io/badge/Skill Level-Intermediate%2FAdvanced-purple?style=flat-square"/>

</div>

---

## ğŸ§  Apa Yang Akan Kamu Pelajari?

- Memahami konsep dasar dan arsitektur JWT.
- Cara mengimplementasikan autentikasi dan otorisasi menggunakan JWT dalam aplikasi web.
- Bagaimana membuat, memverifikasi, dan memperbarui token JWT.
- Praktik terbaik untuk mengamankan token JWT dari serangan umum.
- Mengintegrasikan JWT dengan framework backend populer (Node.js/Express).
- Menangani refresh token untuk meningkatkan keamanan dan pengalaman pengguna.

---

## ğŸ“Œ Introduction

Dalam dunia pengembangan web modern, keamanan adalah hal yang mutlak.  Autentikasi dan otorisasi yang tepat adalah fondasi dari aplikasi web yang aman.  JWT (JSON Web Token) telah menjadi standar industri untuk mengamankan aplikasi web dan API.  JWT adalah cara ringkas dan mandiri untuk mewakili klaim (claims) antara dua pihak. Klaim ini dapat diverifikasi dan dipercaya karena ditandatangani secara digital.

JWT sangat berguna untuk Single Sign-On (SSO) dan otentikasi API. Bayangkan kamu memiliki sebuah aplikasi yang membutuhkan autentikasi pengguna. Dengan JWT, server autentikasi dapat mengeluarkan token setelah pengguna berhasil login. Token ini kemudian disimpan di sisi klien (misalnya, di browser menggunakan localStorage atau cookies). Setiap kali klien ingin mengakses sumber daya yang dilindungi, ia akan menyertakan token JWT dalam header permintaan. Server kemudian akan memverifikasi token tersebut untuk memastikan bahwa pengguna memiliki izin untuk mengakses sumber daya tersebut.

Keuntungan utama menggunakan JWT meliputi:

*   **Stateless:** Server tidak perlu menyimpan informasi sesi.  Setiap token berisi semua informasi yang diperlukan untuk autentikasi.
*   **Scalable:** Karena stateless, JWT sangat mudah diskalakan.
*   **Secure:** JWT dapat ditandatangani secara digital menggunakan algoritma seperti HMAC atau RSA.
*   **Cross-Domain:** JWT dapat digunakan di berbagai domain karena tidak bergantung pada cookies.

Dalam tutorial ini, kita akan membahas secara mendalam tentang JWT, mulai dari konsep dasar hingga implementasi praktis, serta praktik terbaik untuk mengamankan aplikasi web kita. Kita akan menggunakan Node.js dan Express sebagai contoh backend, tetapi prinsip-prinsip yang sama dapat diterapkan pada bahasa dan framework backend lainnya. Mari kita mulai!

---

## âš™ï¸ Requirements

- OS: Sistem operasi apa pun (Windows, macOS, Linux)
- Software:
    - Node.js (versi 14 atau lebih tinggi)
    - npm (Node Package Manager) atau yarn
    - Text editor atau IDE (VS Code, Sublime Text, dll.)
    - Postman atau alat sejenis untuk menguji API
- Prior Knowledge:
    - Pemahaman dasar tentang JavaScript
    - Pengetahuan dasar tentang Node.js dan Express
    - Konsep HTTP dan RESTful API
- Optional Tools:
    - nodemon (untuk hot-reloading server selama pengembangan)

---

## ğŸ§± Step-by-Step Guide

### **Step 1 â€”  Setting Up the Project ğŸ—ï¸**

Langkah pertama adalah membuat direktori proyek baru dan menginisialisasi proyek Node.js.

```bash
mkdir jwt-auth
cd jwt-auth
npm init -y
```

Perintah di atas akan membuat file `package.json` dengan konfigurasi default. Selanjutnya, kita perlu menginstal dependencies yang diperlukan:

```bash
npm install express jsonwebtoken bcryptjs dotenv
npm install -D nodemon
```

*   `express`: Framework web Node.js yang minimalis dan fleksibel.
*   `jsonwebtoken`: Library untuk membuat dan memverifikasi JWT.
*   `bcryptjs`: Library untuk mengenkripsi password.
*   `dotenv`: Library untuk memuat variabel lingkungan dari file `.env`.
*   `nodemon`: (Sebagai dev dependency) Secara otomatis me-restart server saat perubahan terdeteksi.

Setelah instalasi selesai, tambahkan script `start` dan `dev` ke file `package.json`:

```json
{
  "name": "jwt-auth",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.3"
  }
}
```

Sekarang, buat file `index.js` di root proyek dan file `.env`.  File `.env` akan digunakan untuk menyimpan variabel lingkungan sensitif seperti secret key JWT.

```javascript
// index.js
const express = require('express');
const dotenv = require('dotenv');

dotenv.config(); // Load environment variables from .env file

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json()); // Middleware to parse JSON bodies

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
```

```
# .env
PORT=3000
JWT_SECRET=your-super-secret-key
```

**ğŸ’¡ Tip:**  Jangan pernah menyimpan secret key JWT langsung di kode kamu. Selalu gunakan variabel lingkungan. Ganti `"your-super-secret-key"` dengan secret key yang kuat dan acak.

### **Step 2 â€” Implementing User Registration âœï¸**

Selanjutnya, kita akan mengimplementasikan endpoint untuk pendaftaran pengguna.  Kita akan menggunakan `bcryptjs` untuk mengenkripsi password pengguna sebelum menyimpannya ke database (dalam contoh ini, kita akan menggunakan array in-memory sebagai pengganti database sungguhan).

Buat sebuah folder `routes` dan sebuah file `auth.js` di dalamnya.

```javascript
// routes/auth.js
const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const router = express.Router();

// Dummy user data (in-memory)
const users = [];

// Registration route
router.post('/register', async (req, res) => {
  const { username, password } = req.body;

  // Check if user already exists
  const userExists = users.find(user => user.username === username);
  if (userExists) {
    return res.status(400).json({ message: 'User already exists' });
  }

  // Hash the password
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(password, salt);

  // Create a new user
  const newUser = {
    id: users.length + 1,
    username,
    password: hashedPassword
  };

  users.push(newUser);

  res.status(201).json({ message: 'User registered successfully' });
});

module.exports = router;
```

Kemudian, import dan gunakan route ini di `index.js`:

```javascript
// index.js
const express = require('express');
const dotenv = require('dotenv');
const authRoutes = require('./routes/auth'); // Import auth routes

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());

app.use('/api/auth', authRoutes); // Use auth routes under /api/auth

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
```

Sekarang, kamu dapat menguji endpoint `/api/auth/register` menggunakan Postman. Kirim request POST dengan body JSON seperti ini:

```json
{
  "username": "testuser",
  "password": "password123"
}
```

Kamu akan menerima respons dengan status 201 dan pesan `"User registered successfully"`.

**âš ï¸ Warning:**  Jangan pernah menyimpan password dalam bentuk plain text. Selalu gunakan hashing dengan salt.  `bcryptjs` adalah pilihan yang baik karena secara otomatis menangani salting.

### **Step 3 â€” Implementing User Login and JWT Generation ğŸ”‘**

Setelah pendaftaran, kita perlu mengimplementasikan login dan menghasilkan JWT.  Saat pengguna login, kita akan memverifikasi password mereka dan, jika valid, kita akan menghasilkan JWT yang berisi informasi pengguna.

Tambahkan endpoint `/login` ke `routes/auth.js`:

```javascript
// routes/auth.js
// ... (imports and user data) ...

// Login route
router.post('/login', async (req, res) => {
  const { username, password } = req.body;

  // Find the user
  const user = users.find(user => user.username === username);
  if (!user) {
    return res.status(400).json({ message: 'Invalid credentials' });
  }

  // Check password
  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(400).json({ message: 'Invalid credentials' });
  }

  // Create and assign a token
  const token = jwt.sign({ id: user.id, username: user.username }, process.env.JWT_SECRET, { expiresIn: '1h' });

  res.json({ message: 'Logged in successfully', token });
});

// ... (module.exports) ...
```

Dalam kode di atas:

*   Kita mencari pengguna berdasarkan username.
*   Kita menggunakan `bcrypt.compare` untuk membandingkan password yang dimasukkan dengan password yang sudah di-hash yang tersimpan.
*   Jika password valid, kita menggunakan `jwt.sign` untuk membuat JWT.  Kita menyertakan ID dan username pengguna dalam payload token.
*   Kita menetapkan `expiresIn` untuk token, yang menentukan berapa lama token tersebut valid (dalam contoh ini, 1 jam).
*   Kita mengirimkan token kembali ke klien.

Sekarang, uji endpoint `/api/auth/login` dengan Postman. Kirim request POST dengan body JSON yang berisi username dan password pengguna yang sudah terdaftar. Kamu akan menerima respons dengan status 200 dan JWT di dalam body JSON.

**ğŸ”‘ Tip:**  `expiresIn` sangat penting untuk keamanan. Token yang masa berlakunya singkat lebih aman karena mengurangi risiko jika token tersebut dicuri.

### **Step 4 â€” Implementing Authentication Middleware ğŸ›¡ï¸**

Sekarang kita memiliki JWT, kita perlu mengimplementasikan middleware untuk mengautentikasi pengguna berdasarkan token tersebut. Middleware ini akan memverifikasi token dan, jika valid, akan menambahkan informasi pengguna ke objek request.

Buat file `middleware/auth.js`:

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');

const auth = (req, res, next) => {
  const authHeader = req.header('Authorization');
  const token = authHeader && authHeader.split(' ')[1]; // Bearer <token>

  if (!token) {
    return res.status(401).json({ message: 'No token, authorization denied' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded; // Attach user information to the request
    next();
  } catch (err) {
    res.status(400).json({ message: 'Token is not valid' });
  }
};

module.exports = auth;
```

Dalam kode di atas:

*   Kita mengambil token dari header `Authorization`.  Kita mengharapkan token dalam format "Bearer <token>".
*   Kita menggunakan `jwt.verify` untuk memverifikasi token.
*   Jika token valid, kita mendekode payload token dan menempelkan informasi pengguna ke objek `req.user`.
*   Kita memanggil `next()` untuk melanjutkan ke handler request berikutnya.
*   Jika token tidak valid, kita mengirimkan respons error.

### **Step 5 â€” Protecting Routes with Authentication ğŸ”’**

Sekarang, kita dapat menggunakan middleware otentikasi untuk melindungi route yang membutuhkan autentikasi. Misalnya, kita dapat membuat route yang hanya dapat diakses oleh pengguna yang sudah login.

Tambahkan route berikut ke `index.js`:

```javascript
// index.js
// ... (imports and middleware) ...

const authMiddleware = require('./middleware/auth'); // Import the authentication middleware

// Protected route
app.get('/api/protected', authMiddleware, (req, res) => {
  res.json({ message: 'Protected route accessed successfully', user: req.user });
});

// ... (app.listen) ...
```

Dalam kode di atas, kita menggunakan `authMiddleware` sebagai argumen kedua untuk `app.get`. Ini berarti bahwa middleware otentikasi akan dijalankan sebelum handler request untuk route `/api/protected`.

Untuk mengakses route ini, kamu harus mengirimkan request GET dengan header `Authorization` yang berisi JWT yang valid. Contoh:

```
Authorization: Bearer <your_jwt_token>
```

Jika token valid, kamu akan menerima respons dengan status 200 dan informasi pengguna di dalam body JSON. Jika token tidak valid atau tidak ada, kamu akan menerima respons error.

**ğŸ”’ Tip:** Selalu validasi token JWT di server-side. Jangan hanya bergantung pada validasi di client-side karena dapat dengan mudah di-bypass.

### **Step 6 â€” Handling Refresh Tokens ğŸ”„**

JWT memiliki masa berlaku yang singkat untuk alasan keamanan.  Untuk menghindari pengguna harus login ulang setiap kali token mereka kedaluwarsa, kita dapat menggunakan refresh token.  Refresh token adalah token yang masa berlakunya lebih lama yang dapat digunakan untuk mendapatkan token akses baru tanpa memerlukan kredensial pengguna.

Untuk mengimplementasikan refresh token, kita perlu:

1.  Menyimpan refresh token di database yang terkait dengan pengguna.
2.  Membuat endpoint untuk menukar refresh token dengan token akses baru.

Berikut adalah contoh implementasi:

```javascript
// routes/auth.js
// ... (imports and user data) ...

// In-memory refresh token storage (replace with a database)
const refreshTokens = [];

// Login route (modified to include refresh token)
router.post('/login', async (req, res) => {
  const { username, password } = req.body;

  // Find the user
  const user = users.find(user => user.username === username);
  if (!user) {
    return res.status(400).json({ message: 'Invalid credentials' });
  }

  // Check password
  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(400).json({ message: 'Invalid credentials' });
  }

  // Create access token
  const accessToken = jwt.sign({ id: user.id, username: user.username }, process.env.JWT_SECRET, { expiresIn: '1h' });

  // Create refresh token
  const refreshToken = jwt.sign({ id: user.id, username: user.username }, process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET, { expiresIn: '7d' }); //Use JWT_SECRET as fallback

  // Store refresh token (in-memory - replace with database)
  refreshTokens.push(refreshToken);

  res.json({ message: 'Logged in successfully', accessToken, refreshToken });
});

// Refresh token route
router.post('/token', (req, res) => {
  const { token } = req.body;

  if (!token) {
    return res.status(401).json({ message: 'Refresh token required' });
  }

  if (!refreshTokens.includes(token)) {
    return res.status(403).json({ message: 'Invalid refresh token' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET); //Use JWT_SECRET as fallback
    const accessToken = jwt.sign({ id: decoded.id, username: decoded.username }, process.env.JWT_SECRET, { expiresIn: '1h' });
    res.json({ accessToken });
  } catch (err) {
    return res.status(403).json({ message: 'Invalid refresh token' });
  }
});

// Logout route (invalidate refresh token)
router.delete('/logout', (req, res) => {
  const { token } = req.body;
  refreshTokens = refreshTokens.filter(t => t !== token); //Remove the token from storage
  res.status(204).send(); //No content, successful deletion
});

// ... (module.exports) ...
```

Tambahkan juga ke `.env`:

```
JWT_REFRESH_SECRET=your-super-secret-refresh-key
```

Dalam kode di atas:

*   Kita menghasilkan refresh token saat login.
*   Kita menyimpan refresh token (dalam contoh ini, dalam array in-memory - kamu harus menggunakan database di aplikasi production).
*   Kita membuat endpoint `/token` untuk menukar refresh token dengan token akses baru.
*   Endpoint `/logout` untuk menghapus refresh token saat user logout.
*   Kita memverifikasi refresh token dan menghasilkan token akses baru jika refresh token valid.

**ğŸ”„ Tip:** Refresh token harus disimpan dengan aman (misalnya, dalam database) dan harus di-revoked saat pengguna logout atau jika terjadi kompromi keamanan. Gunakan `JWT_REFRESH_SECRET` yang berbeda dari `JWT_SECRET` untuk keamanan lebih tinggi.

### **Step 7 â€” Best Practices and Security Considerations ğŸ”**

*   **Use HTTPS:** Selalu gunakan HTTPS untuk mengenkripsi komunikasi antara klien dan server. Ini mencegah penyerang mencuri token JWT melalui serangan man-in-the-middle.
*   **Store JWT on the Client-Side Securely:** Hindari menyimpan JWT di `localStorage` jika memungkinkan, karena rentan terhadap serangan XSS (Cross-Site Scripting). Pertimbangkan menggunakan `httpOnly` cookies dengan flag `Secure` dan `SameSite=Strict` untuk meningkatkan keamanan.
*   **Validate JWT on the Server-Side:** Jangan hanya bergantung pada validasi JWT di sisi klien. Selalu validasi token di sisi server untuk memastikan integritas dan keasliannya.
*   **Implement Refresh Token Rotation:** Alih-alih menggunakan refresh token yang sama berulang kali, pertimbangkan untuk membuat refresh token baru setiap kali token akses di-refresh. Ini membatasi dampak jika refresh token dicuri.
*   **Monitor for Suspicious Activity:** Pantau log aplikasi kamu untuk mendeteksi aktivitas mencurigakan, seperti upaya login yang gagal atau penggunaan refresh token yang tidak wajar.

### **Deployment ğŸš€**

Setelah aplikasi kita siap, kita dapat mendeploynya ke platform cloud seperti:

*   **Heroku:** Platform cloud yang mudah digunakan untuk mendeploy aplikasi Node.js.
*   **AWS (Amazon Web Services):** Menyediakan berbagai layanan untuk hosting aplikasi, seperti EC2, Elastic Beanstalk, dan Lambda.
*   **Google Cloud Platform (GCP):** Menawarkan layanan serupa dengan AWS, seperti Compute Engine, App Engine, dan Cloud Functions.
*   **Azure:** Layanan cloud dari Microsoft yang menyediakan berbagai opsi hosting.

Saat mendeploy, pastikan untuk mengatur variabel lingkungan dengan benar. Jangan menyimpan secret key JWT di kode kamu.

### **Troubleshooting ğŸ› ï¸**

*   **"Token is not valid" error:** Pastikan bahwa secret key JWT yang digunakan untuk memverifikasi token sama dengan yang digunakan untuk membuat token. Periksa juga apakah token belum kedaluwarsa.
*   **"No token, authorization denied" error:** Pastikan bahwa header `Authorization` diatur dengan benar dan berisi token JWT yang valid.
*   **CORS issues:** Jika kamu mengalami masalah CORS (Cross-Origin Resource Sharing), pastikan bahwa server kamu dikonfigurasi untuk mengizinkan permintaan dari domain klien kamu. Kamu dapat menggunakan middleware `cors` untuk mengatasi masalah ini.

---

Selamat! Kamu telah berhasil mengimplementasikan autentikasi berbasis JWT dalam aplikasi web kamu. Dengan mengikuti panduan ini, kamu dapat mengamankan aplikasi kamu dari berbagai serangan dan memberikan pengalaman pengguna yang aman dan nyaman. Teruslah belajar dan bereksperimen untuk meningkatkan pemahaman kamu tentang keamanan web.

````